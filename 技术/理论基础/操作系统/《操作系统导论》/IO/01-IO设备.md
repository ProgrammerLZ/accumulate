# IO设备

==关键问题：I/O应该如何集成进系统中？其中的一般机制是什么？如何让它们变得高效？==

## 系统架构

简单的IO系统架构。

![image-20230216222423378](assets/IO%E8%AE%BE%E5%A4%87/image-20230216222423378.png)

* CPU通过某种内存总线（memory bus）或互连电缆连接到系统内存。
* 图像或者其他高性能I/O设备通过常规的I/O总线（I/O bus）连接到系统。
* 更下面是外围总线（peripheral bus），它们将最慢的设备连接到系统，包括磁盘、鼠标及其他类似设备。

在工程上高性能总线的造价非常高。所以，系统的设计采用了这种分层的方式，这样可以让要求高性能的设备（比如显卡）离CPU更近一些，低性能的设备离CPU远一些。将磁盘和其他低速设备连到外围总线的好处很多，其中较为突出的好处就是你可以在外围总线上连接大量的设备。

## 标准设备

同软件一样，硬件也需要一些接口，让系统软件来控制它的操作。因此，所有设备都有自己的**特定接口以及典型交互的协议**。

![image-20230216222537916](assets/IO%E8%AE%BE%E5%A4%87/image-20230216222537916.png)



## 标准协议

第1步，操作系统通过反复读取状态寄存器，等待设备进入可以接收命令的就绪状态。我们称之为轮询（polling）设备（基本上，就是问它正在做什么）。

第2步，操作系统下发数据到数据寄存器。例如，你可以想象如果这是一个磁盘，需要多次写入操作，将一个磁盘块（比如4KB）传递给设备。如果主CPU参与数据移动（就像这个示例协议一样），我们就称之为编程的I/O（programmed I/O，PIO）。

第3步，操作系统将命令写入命令寄存器；这样设备就知道数据已经准备好了，它应该开始执行命令。

最后一步，操作系统再次通过不断轮询设备，等待并判断设备是否执行完成命令。

优点：

这个简单的协议好处是足够简单并且有效。

缺点：

但是难免会有一些低效和不方便。我们注意到这个协议存在的第一个问题就是**轮询过程比较低效**，在等待设备执行完成命令时浪费大量CPU时间，如果此时操作系统可以切换执行下一个就绪进程，就可以大大提高CPU的利用率。

==关键问题：如何减少轮询开销？==

==操作系统检查设备状态时如何避免频繁轮询，从而降低管理设备的CPU开销？==



## 利用中断减少CPU开销

CPU 不再需要不断轮询设备，而是向设备发出一个请求，然后就可以让对应进程睡眠，切换执行其他任务。当设备完成了自身操作，会抛出一个**硬件中断**，引发CPU跳转执行操作系统预先定义好的中断服务例程（Interrupt Service Routine，ISR），或更为简单的中断处理程序（interrupt handler）。中断处理程序是一小段操作系统代码，它会结束之前的请求（比如从设备读取到了数据或者错误码）并且唤醒等待I/O的进程继续执行。

![image-20230216224017097](assets/IO%E8%AE%BE%E5%A4%87/image-20230216224017097.png)

在这个例子中，在磁盘处理进程1的请求时，操作系统在CPU上运行进程2。磁盘处理完成后，触发一个中断，然后操作系统唤醒进程1继续运行。这样，在这段时间，无论CPU还是磁盘都可以有效地利用。



> 中断并非总是比PIO好尽管中断可以做到计算与I/O的重叠，但这仅在慢速设备上有意义。否则，额外的中断处理和上下文切换的代价反而会超过其收益。另外，如果短时间内出现大量的中断，可能会使得系统过载并且引发活锁[MR96]。这种情况下，轮询的方式可以在操作系统自身的调度上提供更多的控制，反而更有效。

另一个基于中断的优化就是**合并**（coalescing）。设备在抛出中断之前往往会等待一小段时间，在此期间，其他请求可能很快完成，因此多次中断可以合并为一次中断抛出，从而降低处理中断的代价。当然，等待太长会增加请求的延迟，这是系统中常见的折中。



## 利用DMA进行更高效的传送

DMA工作过程如下。为了能够将数据传送给设备，操作系统会通过编程告诉DMA引擎:

* 数据在内存的位置，
* 要拷贝的大小以及要拷贝到哪个设备。

在此之后，操作系统就可以处理其他请求了。当DMA的任务完成后，DMA控制器会抛出一个中断来告诉操作系统自己已经完成数据传输

![image-20230217081549837](assets/IO%E8%AE%BE%E5%A4%87/image-20230217081549837.png)



## 设备交互的方法

==关键问题：如何与设备通信硬件如何如与设备通信？是否需要一些明确的指令？或者其他的方式？==

随着技术的不断发展，主要有两种方式来实现与设备的交互。

1. 第一种办法相对老一些（在IBM主机中使用了多年），就是用明确的I/O指令。这些指令规定了操作系统将数据发送到特定设备寄存器的方法，从而允许构造上文提到的协议。
2. 第二种方法是内存映射I/O（memory- mapped I/O）。通过这种方式，**硬件将设备寄存器作为内存地址提供**。当需要访问设备寄存器时，操作系统装载（读取）或者存入（写入）到该内存地址；然后硬件会将装载/存入转移到设备上，而不是物理内存。



## 纳入操作系统：设备驱动程序

每个设备都有非常具体的接口，如何将它们纳入操作系统，而我们希望操作系统尽可能通用。

在最底层，操作系统的一部分软件清楚地知道设备如何工作，我们将这部分软件称为设备驱动程序（device driver），所有设备交互的细节都封装在其中。

![image-20230218235118045](assets/01-IO%E8%AE%BE%E5%A4%87/image-20230218235118045.png)

可以看出，文件系统（当然也包括在其之上的应用程序）完全不清楚它使用的是什么类型的磁盘。其之上的应用程序，完全不清楚它使用的是什么类型的磁盘。它只需要简单地向通用块设备层发送读写请求即可，块设备层会将这些请求路由给对应的设备驱动，然后设备驱动来完成真正的底层操作