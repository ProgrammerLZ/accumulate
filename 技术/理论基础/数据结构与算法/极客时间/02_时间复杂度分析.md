

## 复杂度分析



![image-20181007103533172](./assets/image-20181007103533172.png)



数据结构和算法本身解决的是**“快”**和**“省”**的问题。

复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的基本内容就掌握了一半。

### 一、为什么需要复杂度分析？

我们需要一个不依赖具体环境，不用具体的测试数据，直观上就能估计出算法的执行效率的方法，也就是时间和空间复杂度的分析方法。

实际上通过事后统计法也能够得知算法的好坏，但是这种方法比较依赖数据的规模以及所运行的硬件的配置，所以他是比较依赖于环境的。

复杂度分析是一种可以完全和环境独立开来，只通过这种分析方式就能够粗略得出一个算法的好坏，因此在任何场景都能够使用，这是他的优点。但是，他并不能够精确地得到一个算法的运行时间以及所占内存的大小，这也可以说是他的一个不算是缺点的缺点。



### 二、大O复杂度表示法（算法的复杂度）

一个重要的规律：

> 所有代码的执行时间T(n)与**所有行的代码的执行次数**成正比。

用数学符号表示就是：

> T(n) = O( f(n) )

T(n) : 所有代码的执行时间。

n : 数据的规模。

f(n) : 每行代码执行次数的总和。

O : 表示f(n) 与 T(n) 成正比。

这就是大O时间复杂度表示法。

=，而是代表**随着问题规模的增长，代码执行时间的变化趋势**，因此也叫**渐进时间复杂度**简称**时间复杂度**。



### 三、时间复杂度分析

1. 只关注循环执行次数最多的一段代码

   >  大O复杂度表示的只是一种变化趋势，所以在分析算法的时间复杂度的时候就只分析循环执行次数最多的那一段代码就可以。

2. 加法法则：总复杂度等于量级最大的那段代码的复杂度

   >  如果T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).

3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

   > 如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n) * T2(n)=O(f(n)) * O(g(n))=O(f(n) * g(n)).



### 四、常见的复杂度

![3723793cc5c810e9d5b06bc95325bf0a](./assets/3723793cc5c810e9d5b06bc95325bf0a.jpg)

![497a3f120b7debee07dc0d03984faf04](./assets/497a3f120b7debee07dc0d03984faf04.jpg)

### 五、最好、最坏、平均、均摊时间复杂度

```c
// n 表示数组 array 的长度
int find(int[] array, int n, int x) {
  int i = 0;
  int pos = -1;
  for (; i < n; ++i) {
    if (array[i] == x) pos = i;
  }
  return pos;
}
```

最好时间复杂度：O(1)

最坏时间复杂度：O(n)

平局时间复杂度：O(n)

均摊时间复杂度：

