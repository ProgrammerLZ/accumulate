## 排序

2018-10-16

### 一、如何分析排序算法



**排序算法需要掌握**：

- 算法原理

- 代码实现

- 评价分析

  ​	一般会从以下几点进行分析

  1. 排序算法的执行效率

     - 最好、最坏、平均时间复杂度

     - 时间复杂度的系数、常数、低阶
     - 比较和交换的次数

  2. 排序算法的内存消耗

     > 原地排序：特指空间复杂度为O(1)的排序算法。

  3. 排序算法的稳定性

     度量指标——算法的稳定性。

     > 算法的稳定性是指，在待排序的序列中，如果存在值相等的元素，经过排序后，相等的元素之间的顺序保持原有的先后顺序不变。

     > 具有稳定性的排序算法要比不具有稳定性的算法好。举例来说，若购物的订单先按时间排序，得到一个按时间正序的订单，这时再按照金额排序，由于算法具有稳定性，金额相等的订单在这次排序之后，仍然能够保持上次排序的按时间正序结果。


### 二、冒泡排序

#### 2.1 算法原理

![9246f12cca22e5d872cbfce302ef4d09 (1)](./assets/9246f12cca22e5d872cbfce302ef4d09 (1).jpg)

#### 2.2 代码实现

```java
// 冒泡排序，a 表示数组，n 表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
 
 for (int i = 0; i < n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < (n - 1) - i; ++j) {
      /*内循环 Start*/
      if (a[j] > a[j+1]) { // 比较
        int tmp = a[j];
        a[j] = a[j+1];//交换
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
      /*内循环 End*/
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}

```

#### 2.3 算法分析

##### 2.3.1 时间复杂度分析

最好：当数据完全有序的情况下，内循环代码执行n-1次。故时间复杂度为O(1)。

最坏：当数据完全倒序的情况下，内循环代码执行（n-1)+(n-2)+...+1= ((n - 1) *n)/2。故时间复杂度为O(n * n)

平均时间复杂度：

先介绍一些概念。

> 有序度：排序算法的有序度，指的是待排序的序列中，所有的有序对的数量。
>
> 如，1、5、4、6，有序对的数量为5，分别是{1,5}{1,4}{1,6}{5,6}{4,6}。

```c
有序元素对：a[i] <= a[j], 如果 i < j。
```

=>

> 满有序度：一个完全有序的序列的有序对数量—>为 **n(n - 1) / 2**。

=>

> 逆序度 = 满有序度 - 有序度

冒泡排序的基本操作为比较和交换。

假设待排序序列初始情况完全有序，有序度为 n(n-1) / 2，逆序度为0，故基本操作的次数为0。

假设待排序序列的初始情况完全逆序，有序度为0，逆序度为n(n-1) / 2，故基本操作的次数为 n(n-1) / 2。

取中间的操作次数为 n(n-1) /4，故平均时间复杂度为O(n * n)。

##### 2.3.2 空间复杂度分析

O(1)。

##### 2.3.3 稳定性

冒泡排序两个相邻的元素交换的条件是：当前元素的下一个元素 > 当前元素，相等的时候不做交换。因此，不会改变相等元素的**前后顺序**。所以冒泡排序具有稳定性。



### 三、插入排序

#### 3.1 算法原理

将需要排序的序列，分为两个区间。一部分成为已排序区间，另一部分称为未排序区间。初始状态的时候，已排序区间为待排序序列的第一个元素。之后，每次都从未排序区间当中取一个数据向已排序序列当中插入，插入的位置需能够保证已排序序列仍然为有序序列。

![b60f61ec487358ac037bf2b6974d2de1-9693831](./assets/fd6582d5e5927173ee35d7cc74d9c401.jpg)

#### 3.2 算法实现

```java
// 插入排序，a 表示数组，n 表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;

  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}

```

#### 3.3 算法分析

##### 3.3.1 时间复杂度分析

最好：O(n)。

最坏：O(n * n)



### 四、选择排序

##### 4.1 算法原理

假设有一个数组A，且其中有一些无序的元素，元素的数量为n。使用选择排序需要遍历数组n次，每次从中取出一个最大的元素（规则上是最大的那个，规则自己定）放入数组B中，遍历完后，数组B即为一个有序的列表。

##### 4.2 算法实现

```JAVA

```



##### 4.3 算法分析











