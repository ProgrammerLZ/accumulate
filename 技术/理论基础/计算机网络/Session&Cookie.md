## 概述

网站的后端在处理各种前端请求的时候，是不带有记忆功能的，也就是说两次请求之间毫无关联，后端服务不负责记录任何的状态，每一次请求都是一次完整的单独的操作，这是有HTTP协议的无状态性决定的。然而，这种无状态性在某些时候无法满足应用程序的需求，于是Session和Cookie的技术就应运而生，他们本质上是为了给无状态的HTTP协议进行一种增强，从而满足应用程序对记忆状态的需求。

## HTTP无状态的特性

指的是两次请求之间，不存在任何的相关性。他不对之前发生过的请求和响应进行状态管理，也就是说无法根据之前的状态进行本次的处理。

## Cookie特性

方向：服务器->浏览器

携带方式：响应头、请求头

可被用户禁用

由浏览器负责实现，将Cookie信息统一存放在一个位置

以key-value的形式存在

## Session特性

由web容器负责创建，通过Servlet进行获取，每次对浏览器的响应都在响应头当中向客户端返回SessionId，下一次浏览器自动将cookie携带回来，通过cookie中的sessionId，就可以在服务器端获取对应的Session

依赖于浏览器的Cookie，如果浏览器Cookie被禁用会产生Session无法共享的问题

`web容器由于需要处理Session，因此会占用一部分内存和CPU资源，这也是Tomcat的最大连接数只有200个的原因`。(这部分存疑)

## 实际场景的一些问题

### Cookie被禁用

* encodeURL
* encodeRedirectURL

通过以上两个API对URL进行重写，该重写会在URL上携带sessionId而不是在cookie中。

### Session同步

首先是为什么会有这样的概念出现？

先考虑这样一个问题，现在我的应用需要部署在3台机器上。是不是出现这样一种情况，我第一次登陆，请求去了机器1，然后再机器1上创建了一个session；但是我第二次访问时，请求被路由到机器2了，但是机器2上并没有我的session信息，所以得重新登录。当然这种可以通过nginx的IP HASH负载策略来解决。对于同一个IP请求都会去同一个机器。

但是业务发展的越来越大，拆分的越来越多，机器数不断增加；很显然那种方案就不行了。那么这个时候就需要考虑是不是应该将session信息放在一个独立的机器上，所以分布式session要解决的问题其实就是分布式环境下的session共享的问题。

关于session独立部署的方式有很多种，可以是一个独立的数据库服务，也可以是一个缓存服务(redis，目前比较常用的一种方式，即使用Redis来作为session缓存服务器)。