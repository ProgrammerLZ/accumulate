## 内存模型与线程

### 主内存与工作内存

Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。![image-20230706212339250](assets/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230706212339250.png)





### 内存间交互操作

* lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
* unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
* read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
* load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
* use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
* assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
* store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
* write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。



### volatile

JVM提供的最轻量级的同步机制

作用

1. 保证变量对所有线程的可见性

   当一条线程修改了一个变量，这个变量的值对于其他线程来说是立即可见的

2. 禁止指令重排

   * 内存屏障：指的是重排序时不能把后面的指令重排序到内存屏障之前

性能

1. 读与普通变量没什么区别

2. 写会慢，因为插入了内存屏障
3. 通常情况下比锁快，只要volatile能够满足场景，就可以选择volitile



### 原子性、可见性、有序性

原子性：操作不可再分

* 基本数据类型的访问读写是具备原子性的
* synchronized块之间的操作也具备原子性

可见性：一个线程修改了变量值对另外的线程立即可见

* Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的

* synchronized和final修饰的变量也具备可见性

有序性

* volitile和synchronized都能实现有序性



### 先行发生原则

这个原则非常重要，**它是判断数据是否存在竞争、线程是否安全的主要依据**，依靠这个原则，我们可以通过几条规则一揽子地解决并发环境下两个操作之间是否可能存在冲突的所有问题。

* 程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。
*  管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。
* volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。
* 线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。
* 线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。
* 线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先

时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。xxxxxxxxx



## Java与线程

### 线程的实现

* 主流操作系统都提供了线程的实现，Java语言则统一了操作系统这一层的差异，提供了一个对线程同意处理的API
* Thread类的大部分API都是native的
  * native意味着：
    * 无法通过平台无关的手段进行实现
    * 为了性能
* 线程实现的三种方式：
  * 使用内核线程实现
  * 使用用户线程实现
  * 以上两种的混合实现



### Java线程的调度

* 调度方式：
  * 协同式
  * 抢占式
* Java可以设置线程的优先级，但是并不能作为可信赖的线程执行优先程度的依据



### 状态转换

![image-20230708174947916](assets/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230708174947916.png)



