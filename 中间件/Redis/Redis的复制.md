# Redis的复制

在分布式系统中为了解决单点问题，通常会把数据复制多个副本部署到其他机器，满足故障恢复和负载均衡等需求。Redis也是如此，它为我们提供了复制功能，实现了相同数据的多个Redis副本。复制功能是高可用Redis的基础，更高级别的功能，哨兵和集群都是基于复制实现的。

Redis的主从节点遵从，一主多从，一从一主原则。复制的数据流只能有主节点流向从结点。



## 配置

| 配置功能   | 配置方式 | 具体操作                                                     | 说明                                                         |
| :--------- | :------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 建立复制   | 配置文件 | `slaveof {masterHost} {masterPort}`                          | 建立从结点到主节点的复制关系                                 |
| 建立复制   | 启动项   | 在redis-server启动命令后加入`--slaveof {masterHost} {masterPort}` | 建立从结点到主节点的复制关系                                 |
| 建立复制   | 动态配置 | 使用命令`slaveof {masterHost} {masterPort}`                  | 建立从结点到主节点的复制关系                                 |
| 断开复制   | 动态配置 | `slaveof no one`                                             | 断开从结点到主节点的复制关系                                 |
| 切换主节点 | 动态配置 | `slaveof {newMasterIp} {newMasterPort}`                      | 更换用于复制的主节点                                         |
| 安全配置   | 配置文件 | `requirepass`                                                | 主节点要求从结点进行密码验证                                 |
| 安全配置   | 配置文件 | `masteruath`                                                 | 若主节点配置了`requirepass`从结点要配置成跟主节点密码保持一致，保证能够正常连接主节点并发起复制流程 |
| 只读       | 配置文件 | `slave-read-only=yes`                                        | 配置从结点为只读模式，避免主从数据不一致                     |
| 传输延迟   | 配置文件 | `repl-disable-tcp-nodelay`                                   | 默认关闭，主节点的数据无论大小都会及时的发给从结点，这样主从之间延迟会变小，但增加了网络带宽的消耗，适用于主从之间网络环境良好的场景；<br>开启时，主节点会合并较小的TCP数据包从而节省带宽。默认发送 时间间隔取决于Linux的内核，一般默认为40毫秒。这种配置节省了带宽但增大主从之间的延迟。 |

断开复制的主要流程：

1. 断开与主节点复制关系，不会抛弃原有数据。

2. 从节点晋升为主节点。

切主操作流程如下:

1. 断开与旧主节点复制关系
2. 与新主节点建立复制关系
3. 删除从节点当前所有数据
4. 对新主节点进行复制操作。



## 复制的拓扑结构

### 一主一从

![image-20220620112820961](Redis的复制.assets/image-20220620112820961.png)

用于主节点出现宕机时从结点提供故障转移支持。

> 故障转移：即当活动的服务或应用意外终止时，快速启用冗余或备用的服务器、系统、硬件或者网络接替它们工作

当写命令并发量较高且需要持久化时，可以只在从结点上开启AOF，避免AOF持久化对主节点的性能影响。<u>**此时如果主节点脱机要避免自动重启操作，因为由于主节点没有开启AOF，重启后它的数据集为空，从结点如果继续复制主节点会导致从结点数据也被清空的情况**</u>。安全做法是先在从结点上执行`slaveof no one`断开复制关系，再重启主节点。



### 一主多从（又称星型拓扑结构）

![image-20220620112838879](Redis的复制.assets/image-20220620112838879.png)

应用端可以利用多个从结点实现读写分离。该结构有以下好处：

* 在读占比较大的场景，可以把读命令发送到从结点来分担主节点压力；
* 一些比较好使的读命令，如：keys、sort等，可以在其中一台从结点上执行；

同时也有其弊端：

* 对于写并发量较高的场景，多个从结点会导致主节点写命令的多次发送从而过渡消耗网络带宽，同时也加重了主节点的负载，影响服务稳定性。





### 树状主从（又称树状拓扑）

<img src="Redis的复制.assets/image-20220620114334639.png" alt="image-20220620114334639" style="zoom:70%;" />

树状结构解决了一主多从结构的弊端，使得从节点不但可以复制主节点 数据，同时可以作为其他从节点的主节点继续向下层复制。当主节点需要挂载多个从节点时为了避免对主节点的性能干扰，可以采用树状主从结构降低主节点压力。



## 复制原理

### 复制过程

<img src="Redis的复制.assets/image-20220620115044895.png" alt="image-20220620115044895" style="zoom:50%;" />



1. 保存主节点数据

   slaveof后，从结点只保存主节点的地址信息便返回。执行`info replication`可以看到如下信息：

   ```
   master_host:127.0.0.1 
   master_port:6379
   master_link_status:down
   ```

   注意：主节点连接状态（master_link_status）是down。

   同时，从结点的Redis会打印如下日志：

   ```
   SLAVE OF 127.0.0.1:6379 enabled (user request from 'id=65 addr=127.0.0.1:58090 fd=5 name= age=11 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=0 qbuf-free= 32768 obl=0 oll=0 omem=0 events=r cmd=slaveof')
   ```

2. 建立socket连接。

   从结点执行定时任务（每秒），该任务发现存在新的主节点，就尝试与该节点建立网络连接，从结点会专门建立一个socket套接字转么用于接受主节点发送的复制命令。

   从结点连接成功，打印如下日志：

   ```
   Connecting to MASTER 127.0.0.1:6379 
   MASTER <-> SLAVE sync started
   ```

   从结点连接失败，打印如下日志：

   ```
   Error condition on socket for SYNC: {socket_error_reason}
   ```

   定时任务会无限重试直到连接成功或者执行slaveof no one取消复制。

3. 发送ping命令

   连接成功后，从结点向主节点发送ping命令，首次进行通信，ping命令主要目的如下：

   * 检测主从之间网络套接字是否可用；
   * 检测主节点当前是否可接受处理命令。

   如果ping命令没有收到回复或者超时，从结点会断开复制链接，下次定时任务会重新执行该流程。

4. 权限验证

   配置那节里边已经记录过了，在此不再详细记录。

5. 同步数据集

   对于首次建立复制的场景，主节点会把持有的数据全部发送给从结点，该操作很耗时。Redis2.8以后得数据同步采用`psync`，优化了这种耗时的场景。psync被划分为两种情况：

   * 全量同步
   * 部分同步

6. 命令持续复制

   第5步完成后，复制的建立流程就结束了。接下来主节点会持续的把写命令发送给从结点。



### 数据同步的关键组件

数据同步分为全量复制和部分复制，部分复制是对全量同步的重大优化。2.8版本以后得Redis才支持。

部分复制需要以下组件支持：

* 主从节点各自复制偏移量；
* 主节点复制积压缓冲区；
* 主节点运行id。



1. 复制偏移量

   ![image-20220620143524046](Redis的复制.assets/image-20220620143524046.png)

   * 参与于复制的主从节点都会维护自身复制偏移量；

   * 主节点处理完写入命令后，会把命令的字节长度做累加统计；
   * 从节点在接收到主节点发送的命令后，也会累加记录自身的偏移量；

   * 从结点每秒上报自身的复制偏移量给主节点，因此主节点也会保存从结点的复制偏移量。



2. 复制积压缓冲区

   ![image-20220620144017085](Redis的复制.assets/image-20220620144017085.png)

   * 保存在主节点上的一个**固定长度的队列**，默认大小1MB；
   * 当主节点有连接的从节点时被创建；
   * 主节点响应写命令时，不但会把命令发送给从节点，还会写入复制积压缓冲区；
   * **起到保存最近已复制数据的作用，用于部分复制和复制命令丢失的数据补救**。

   


3. 主节点运行ID

   * 每个Redis节点启动后都会动态分配一个40位的十六进制字符串作为运 行ID；
   * 主要作用是用来唯一识别Redis节点；
   * 运行ID变化后从节点将做全量复制；
   * Redis关闭再启动后，运行ID会随之改变。`debug reload`命令重新加载RDB可以保持运行ID不变，从而有效避免不必要的全量复制。

   > debug reload命令
   >
   > debug reload命令会阻塞当前Redis节点主线程，阻塞期间会生成本地 RDB快照并清空数据之后再加载RDB文件。因此对于大数据量的主节点和无 法容忍阻塞的应用场景，谨慎使用。



4. psync

   <img src="Redis的复制.assets/image-20220620145827128.png" alt="image-20220620145827128" style="zoom:80%;" />

   * 命令格式`psync {runId} {offset}`

     | 参数   | 含义               |
     | ------ | ------------------ |
     | runId  | 主节点Id           |
     | offset | 从结点的复制偏移量 |

   * 运行流程

     1. 从结点发送psync命令给主节点
     2. 主节点根据自身情况相应结果
        * FULLRESYNC：从结点触发全量复制；
        * CONTINUE：从结点触发部分复制；
        * ERR：无法识别psync，从结点发送旧版sync命令触发全量复制。

     

### 数据同步——全量复制

触发全量复制的命令是`sync`和`psync`，根据不同的版本选用不同的命令。

| 版本  | 触发全量复制使用的命令 |
| ----- | ---------------------- |
| < 2.8 | sync                   |
| >=2.8 | psync                  |

全量复制的流程如图所示：

![image-20220620150754628](Redis的复制.assets/image-20220620150754628.png)



1. 从结点发起全量同步；

2. 主节点响应FULLRESYNC；

3. 从结点保存masterInfo：

   * runid
   * offesset

4. 主节点`bgsave`，保存RDB文件到本地；

5. 主节点发送RDB文件给从结点；

   数据量较大的主节点要格外小心，传出RDB文件的速度取决于主从节点之间的网络带宽，如果传输过程比较慢，会因为网络超值导致全量复制失败。

   | 配置项         | 作用                                 |
   | -------------- | ------------------------------------ |
   | `repl-timeout` | 配置RDB传输的网络超时时间，默认：60s |

   对于网络性能不太好的机器，应该适当针对此参数进行调优。

   > 无盘复制
   >
   > 为了降低主节点磁盘开销，Redis支持无盘复制，生成的RDB文件不保存到硬盘而是直接通过网络发送给从节点，通过`repl-diskless-sync`参数控制，默认关闭。无盘复制适用于主节点所在机器磁盘性 能较差但网络带宽较充裕的场景。线 上使用需要做好充分测试。

6. 发送缓冲区的数据；

   从结点接受RDB文件知道接受完成期间，主节点依然响应应用的读写命令，这些命令保存在**复制客户端缓冲区**内，RDB文件接收完后，缓冲区内的数据会被发送给从结点，该步骤完成后，主节点则认为全量复制完成。对于高流量写入的应用，缓冲区可能会产生溢出，可通过`client-output-buffer-limit`进行配置；

   | 配置项                        | 作用                                                         |
   | ----------------------------- | ------------------------------------------------------------ |
   | `client-output-buffer-limit ` | 默认：slave256MB64MB60，如果60秒内缓冲区消耗持续大于 64MB或者直接超过256MB时，主节点将直接关闭复制客户端连接 |

7. 从结点清空自身旧数据；

8. 从结点加载RDB文件；

   耗时操作，读写分离的场景下，在从结点执行复制期间，客户端可能会读取到过期的数据。可通过`slave-serve-stale-data`进行调优。
   
   | 配置项                   | 作用                                                         |
   | ------------------------ | ------------------------------------------------------------ |
   | `slave-serve-stale-data` | 如果开启则从节点依然响应所有命令。对于无法容忍不 一致的应用场景可以设置no来关闭命令执行 |
   
9. 从节点成功加载完RDB后，如果当前节点开启了AOF持久化功能， 它会立刻做bgrewriteaof操作，为了保证全量复制后AOF持久化文件立刻可用。



### 数据同步——部分复制

![image-20220620162328454](Redis的复制.assets/image-20220620162328454.png)



部分复制主要是依赖主节点中的`repl-backlog-buffer`实现的。若从结点发生断线重连的情况，从结点会向主节点发送psync {offset} {runid}命令，主节点会检查offset之后的数据是否还在repl-backlog-buffer当中，如果存在则把这部分数据发送给从结点，否则将触发全量复制。



### 心跳

从服务器以每秒一次的频率像主服务器发送命令：

`REPLCONF ACK <replication offset>`,replication offset是当前从服务器的偏移量。心跳主要有3个作用。

* 检测主从服务器之间的网络状态；
* 复制实现min-slaves选项；
* 实现命令丢失情况下的，主节点给从结点的命令补发操作。













