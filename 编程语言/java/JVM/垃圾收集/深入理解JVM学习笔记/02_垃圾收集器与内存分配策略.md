## 概述

* GC最基本的3个问题：

  * 那哪些内存需要回收

  * 什么时候回收

  * 如何回收


* 内存的动态分配与回收都是”自动化“的为什么需要了解GC？

  当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节

* 内存分配与回收主要关注：

  * Java堆
  * 方法区

  这两部分区域。



## 对象已死吗

第一件事，判断对象是否还存活。



### 引用计数算法

他很好，但还不够好，主要是很难解决**循环引用**问题。

主流虚拟机不使用引用计数来作为对象是否存活判断的算法。



### 可达性分析算法

某个对象没有GCRoot对其实可达的，该对象就可被回收。

![Screen Shot 2019-05-29 at 2.05.45 PM](./assets/02_垃圾收集器与内存分配策略/Screen Shot 2019-05-29 at 2.05.45 PM.png)

在Java语言中，可作为GC Roots的对象包括下面几种：

* 虚拟机栈（栈帧中的本地变量表）中引用的对象。
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象。
* 本地方法栈中JNI（即一般说的Native方法）引用的对象。



### 再谈引用

JDK1.2之前的引用的概念定义很传统，引用被定义成一个指向另一块内存的内存空间所存储的数据。如果从这个定义之上来讨论一个对象的状态，就只存在两种状态：

* 被引用
* 没有被引用

这样，一些中间状态的对象状态就无法表示。

JDK1.2后，对这个定义进行了扩充，引用可分为：

* 强引用
* 软引用
* 弱引用
* 虚引用

这些引用类型对对象的引用，从强到弱。



### 生存还是死亡

判定对象死亡分两步进行标记：

1. 第一次标记📌：利用可达性分析算法判定其是否还在被引用，若没有则进行标记。然后根据情况考虑是否要执行finalize()方法，需要执行则把对象放入F-Queue队列中，并稍后在一个由虚拟机自动建立的、低优先级的线程中执行。
2. 第二次标记📌：在F-Queue中的对象进行第二次标记，对象可能在finalize()方法中进行自救（与GC Root相关联），此时可以把它移除将要回收的集合，若对象没有进行自救，那么这个对象基本就是要被回收了的。

> 注意：对象finalize()方法只会被调用一次。



### 回收方法区

回收条件极为苛刻，主要针对常量池中不再使用的常量进行回收。可通过虚拟机参数设定是否需要回收此区域，感觉在java web的开发过程中，这块区域的垃圾回收并不是那么重要，不多做记录。



## 垃圾收集算法

### 标记清除算法

![image-20230711122030939](assets/02_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20230711122030939.png)

最基础的算法，其他的都是根据这个算法优化得来的，这个算法的不足之处：

* 标记和清除的效率都不高
* 会产生大量的内存碎片，导致之后的大对象无法找到连续的内存空间进行分配。



### 复制算法

![Screen Shot 2019-05-29 at 4.39.52 PM](./assets/02_垃圾收集器与内存分配策略/Screen Shot 2019-05-29 at 4.39.52 PM.png)

现代虚拟机采用这种手机算法来回收新生代（注意：新生代）。

* 缺点：这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。

* 基于缺点进行优化： 
  1. 将新生代内存分为3块，一块较大的Eden和两块较小的Survivor，默认比例8：1：1
  2. 这样，新生代当中的可用内存则变为了90%（优化前是50%）
  3. 当垃圾回收的时候，将Eden和其中一块Survivor上还存活着的对象一次性copy到另一块Survivor上
  4. 担保机制：如果回收之后，剩余的对象超过了10%，这些对象将被送入老年代当中
  5. 最后清理掉Eden和那块用过的Survivor的内存空间。

这个算法，建立在新生代**朝生夕死**的特性之上(98%的对象，在垃圾收集的时候都死了)。为了应对存活对象过多的而导致的Survivor（存放活下来的对象那块空间）空间不够的特殊情况，还需要一种担保机制，也就是把老生代的内存空间作为担保（请理解担保的概念），一旦发生特殊情况，就把多存活下来的那些对象copy到老生代的控件当中去。



### 标记-整理算法

![Screen Shot 2019-05-29 at 4.59.05 PM](./assets/02_垃圾收集器与内存分配策略/Screen Shot 2019-05-29 at 4.59.05 PM.png)

该算法是老年代的收集算法。



## HotSpot算法实现

首先是HotSpot的发起垃圾回收。

发起内存回收有很多的条件限制，虚拟机并不能在任意的结点发起内存回收，虚拟机在发起内存回收之前主要需要关注三点：

* GCRoot的查找效率问题。

  因为为了保证可达性分析的准确性，虚拟机必须要分析对象的引用关系，分析过程要求内存中的对象的引用关系不能发生变化，必须进行stop the world，因此该过程对时间是敏感的，如果效率低下会导致执行系统要等待GC很久才能恢复执行。

* 线程是否处于Safe Point

* 线程是否处于Safe Region



### 垃圾收集器

接下来是HotSpot的垃圾收集器。

这里讨论的收集器基于JDK 1.7 Update 14之后的HotSpot虚拟机（在这个版本中正式提供了商用的G1收集器，之前G1仍处于实验状态），这个虚拟机包含的所有收集器如图所示。

![image-20230722170611039](assets/02_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20230722170611039.png)

* 垃圾收集器之间的连线代表他们可以配合使用。
* 所处的区域代表其进行垃圾收集的区域是老年代还是新生代。
* 这些垃圾收集器不存在一款完美的收集器，都是在合适的场景下才会采用哪种垃圾收集器。



### GC日志

```
33.125: [GC [DefNew: 3324K->152K(3712K), 0.0025925 secs] 3324K->152K(11904K), 0.0031680 secs]
100.667: [Full GC [Tenured: 0K->210K(10240K), 0.0149142 secs] 4603K->210K(19456K), [Perm : 2999K->2999K(21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]
```

* 33.125：GC发生的时间，虚拟机启动以来经过的秒数
* GC：垃圾收集的停顿类型
* DefNew：GC发生的区域
* 3324K->152K(3712K)：该内存区域已使用容量->GC后该内存区域已使用容量（该内存区域总容量）
* 3324K->152K(11904K)：Java堆已使用容量->GC后Java堆已使用容量（Java堆总容量）
* 0.0031680 secs：该内存区域GC所占用的时间



### 垃圾收集器参数总结

![image-20230722183339020](assets/02_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20230722183339020.png)



## 内存分配与回收策略

Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：

* 给对象分配内存
* 回收分配给对象的内存

内存分配的规则并非完全固定，取决于以下因素：

* 垃圾收集器的组合
* 虚拟机中与内存相关的参数设置

这里讨论的是Serial / Serial Old这个组合（Client模式下运行的虚拟机默认的垃圾收集器组合）的内存分配和回收策略。

> 新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。
>
> 老年代GC（Major GC / Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。



### 对象优先在Eden分配

假设虚拟机的参数配置为：*-Xms20M -Xmx20M -Xmn10M XX:SurvivorRatio=8*，堆内存的示意图如下：

![image-20230723183242782](assets/02_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/image-20230723183242782.png)

1. 大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。
2. Minor GC会对Eden区进行回收，会标记并回收Eden的垃圾对象，并把剩余的存活对象移入Survivor区
3. 如果Survivor区域无法容纳剩余生存的这些对象，对象将会被移入老年代——分配担保机制

```
private static final int _1MB = 1024 ＊ 1024;
/＊＊
 ＊ VM 参 数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails-XX:SurvivorRatio=8
 ＊ -XX:PretenureSizeThreshold=3145728
 ＊/
public static void testPretenureSizeThreshold() {
    byte[] allocation;
    allocation = new byte[4 ＊ _1MB]; //直接分配在老年代中
}
```



### 大对象直接进入老年代

虚拟机参数：*-XX:PretenureSizeThreshold*表示大于此值的对象直接分配进入老年代。

>PretenureSizeThreshold参数只对*Serial*和*ParNew*两款收集器有效，Parallel Scavenge收集器不认识这个参数，Parallel Scavenge收集器一般并不需要设置。如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合。



### 长期存活的对象进入老年代

虚拟机参数：*-XX:MaxTenuringThreshold*表示新生代大于此年龄的对象将被移入老年代。

* 虚拟机给每个对象定义了一个对象年龄（Age）计数器。
* 如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。
* 对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。
* 对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。



### 动态对象年龄判断

为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代。

*在进行Minor GC的时候，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。*



### 空间分配担保

空间分配担保策略在进行垃圾回收的时候，是否要进行Full GC的依据。其主要的目的是判断老年代是否能够保证新生代一次安全的Minor GC。该策略的判断过程如下：

* 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的，则直接可以进行Minor GC。

* 如果上述的条件不成立，则虚拟机会查看*HandlePromotionFailure*设置值是否允许担保失败。

  * 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小
    * 如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；
    * 如果小于，进行一次Full GC。

  * 如果不允许，进行一次FullGC

在JDK 6 Update 24之后，HandlePromotionFailure这个虚拟机参数起作用了。其空间分配担保策略改为：*只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC*。



## 总结

内存回收与垃圾收集器在很多时候都是影响系统性能、并发能力的主要因素之一，虚拟机之所以提供多种不同的收集器以及提供大量的调节参数，是因为只有根据实际应用需求、实现方式选择最优的收集方式才能获取最高的性能。没有固定收集器、参数组合，也没有最优的调优方法，虚拟机也就没有什么必然的内存回收行为。因此，学习虚拟机内存知识，如果要到实践调优阶段，那么必须了解每个具体收集器的行为、优势和劣势、调节参数。
