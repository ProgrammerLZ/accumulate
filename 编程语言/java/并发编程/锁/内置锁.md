

# 内置锁的核心原理

## 线程安全问题

线程安全问题主要说的是多个线程在访问共享变量的时候，是否会引发一些并发问题。在线程安全问题当中，涉及到几个概念：

* 临界区资源

* 临界区代码段

* 进入区

* 退出区

在Java中，除了使用synchronized关键字还可以使用Lock显式锁实例，或者使用原子变量（Atomic Variables）对临界区代码段进行排他性保护。Lock显式锁、原子变量暂不在这里讨论，先说说较为基本的同步机制synchronized。



## Synchronized

每个Java对象都隐含有一把锁，这里称为Java内置锁（或者对象锁、隐式锁）。使用synchronized（syncObject）调用相当于获取syncObject的内置锁，所以可以使用内置锁对临界区代码段进行排他性保护。

Synchronized修饰方法，使用this的监视锁作为同步锁；修饰代码块，需手动创建对象。使用synchronized关键字修饰static方法时，synchronized的同步锁并不是普通Object对象的监视锁，而是类所对应的Class对象的监视锁，可以称为类锁，类锁是非常粗粒度的锁，会非常影响并发情况下的程序性能。

通过synchronized抢占的同步锁释放的时机：

* 代码执行完毕
* 程序出现异常

所以，使用synchronized块时不必担心监视锁的释放问题。





## Java对象结构与内置锁

### 对象结构

![image-20230910184930023](assets/%E5%9F%BA%E6%9C%AC%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/image-20230910184930023.png)

Object实例结构中几个重要的字段的作用做一下简要说明：

（1）Mark Word（标记字）字段主要用来表示对象的线程锁状态，另外还可以用来配合GC存放该对象的hashCode。

（2）Class Pointer（类对象指针）字段是一个指向方法区中Class信息的指针，意味着该对象可随时知道自己是哪个Class的实例。（3）Array Length（数组长度）字段占用32位（在32位JVM中）字节，这是可选的，只有当本对象是一个数组对象时才会有这个部分。

（4）对象体用于保存对象属性值，是对象的主体部分，占用的内存空间大小取决于对象的属性数量和类型。

（5）对齐字节并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。当对象实例数据部分没有对齐（8字节的整数倍）时，就需要通过对齐填充来补全。



### Markword与内置锁

Java内置锁涉及很多重要信息，这些都存放在对象结构中，并且存放于对象头的Mark Word字段中。内置锁的状态总共有4种，级别由低到高依次为：无锁、偏向锁、轻量级锁和重量级锁，4种状态会随着竞争的情况逐渐升级，而且是不可逆的过程。



#### 无锁

Java对象刚创建时还没有任何线程来竞争，说明该对象处于无锁状态（无线程竞争它），这时偏向锁标识位是0，锁状态是01。

![image-20240721185154192](/Users/maggie/Library/Application Support/typora-user-images/image-20240721185154192.png)



#### 偏向锁

偏向锁是指一段同步代码一直被同一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。如果内置锁处于偏向状态，当有一个线程来竞争锁时，先用偏向锁，表示内置锁偏爱这个线程，这个线程要执行该锁关联的同步代码时，不需要再做任何检查和切换。偏向锁在竞争不激烈的情况下效率非常高。锁对象的Mark Word会记录自己偏爱的线程ID，内置锁会将该线程当作自己的熟人。

![image-20240721185247771](/Users/maggie/Library/Application Support/typora-user-images/image-20240721185247771.png)



#### 轻量级锁状态

当有两个线程开始竞争这个锁对象时，情况就发生变化了，不再是偏向（独占）锁了，锁会升级为轻量级锁，两个线程公平竞争，哪个线程先占有锁对象。锁对象的Mark Word就指向哪个线程的栈帧中的锁记录。

![image-20240721185322285](/Users/maggie/Library/Application Support/typora-user-images/image-20240721185322285.png)

没有获取到锁的线程会尝试以自旋的方式来获取锁（其实就是一个死循环），其目的是为了避免线程进入内核态挂起线程，如果当前拥有锁的线程很快就执行结束了，那么这个自旋的线程马上就能获取到锁，而避免了内核态和用户态之间的切换。

轻量级锁分为两类：

* 普通自旋锁，固定的自旋次数，可通过JVM参数来更改，默认是10次。
* 自适应自旋锁，根据上一个线程的自旋时间与抢锁结果，来判断当前线程的自旋次数。



#### 重量级锁

自旋获取锁的线程不会无限的进行自旋，毕竟自旋的耗费CPU资源的，当自旋了很久之后还没有获取到锁，自旋获取锁的线程会进入EntrySet，并被标记为Blocking状态，此时轻量级锁也膨胀为重量级锁。锁对象的Mark Word会指向一个监视器对象。

![image-20240721185406031](/Users/maggie/Library/Application Support/typora-user-images/image-20240721185406031.png)

在JVM中每个对象都会关联一个监视器，和对象同时创建并销毁，他的作用是保证同一时间只有一个线程可以访问被保护的临界区代码块。本质上，监视器是一种同步机制。

![image-20240721183220755](/Users/maggie/Library/Application Support/typora-user-images/image-20240721183220755.png)

会让其他申请的线程之间进入阻塞，性能降低。重量级锁也叫同步锁，这个锁对象Mark Word再次发生变化，会指向一个监视器对象，该监视器对象用集合的形式来登记和管理排队的线程。



