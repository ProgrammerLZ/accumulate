---
title: Java集合
date: 2021-07-25 20:29:29
categories: 程序语言
tags: 
- Java
- 集合
- Java基础
---

## Java集合

前两天参与了一次面试，感觉自己写业务代码写的脑子都生锈了，很多Java基础上的东西，虽然之前学过，脑子有一个大致的印象但是几乎忘得都差不多了，面试前准备的也不够充分，回答的也只是蜻蜓点水一样，感觉可能要凉凉了。过阵子可能还要面试，趁周末，重温一下这些较为基础的东西吧。

### HashMap

#### 最简单的考虑

最简单的考虑，可以认为是一个数组。

```java
map.put(key,value)
```

对key做一个hash运算，然后跟底层的数组的长度进行取模就能够得到元素在数组中的索引，然后把value放进数组中的索引指向处即可。



### JDK的优化

```java
map.put("张三","测试数据")；
```

针对上边代码，JDK中对key的hash值的计算有优化，下边是一段hash计算的源码：

```java
static final int hash(Object key){
	int h;
	return (key == null) ? 0 : (he = key.hashCode() ^ (h>>>16))
}
```

> ^ : 异或
>
> h>>>16：将h右移16位
>
> 假设h的hashcode为：1111 1111 1111 1111 1111 1010 0111 1100
>
> 那么h>>>16则为：      0000 0000 0000 0000 1111 1111 1111 1111
>
> 二者异或操作后为：    1111 1111 1111 1111 0000 0101 1000 0011
>
> 转换为int值，

为什么要这么优化呢？优化的是什么呢？后续会说，稍安勿躁。



下边是在数组中进行寻址的代码：

```java
(n-1) & hash
```

> n为数组的长度：假设为16
>
> 二进制的n-1：0000 0000 0000 0000 0000 0000 0000 1111

这段寻址的代码，等价于：

```java
hash % n
```

但是，要比 hash % n要高效得多。前提是 n = 2的整数倍次方。

进行&运算的时候，由于一般情况下，底层数组的长度n都是不会超过32位的，因此，**与hashcode的高16位的运算没什么意义，最终都是0，核心在于低16位的运算**。

现在，就能够知道为什么hash方法到底是做了什么优化了。

hash方法的逻辑是，**将key的hashcode右移16位后与原hashcode进行异或操作**，这就能够让**最终得到的hashcode的低16位同时拥有原hashcode的高16位和低16位的特征，从而降低了hashcode的低16位相同的概率，进而降低了寻址操作得到相同地址的概率。**

其实，最终就是为了避免过多的哈希冲突，这个在下一小节去说。



### 哈希冲突

```java
Map<String,String> map = new HashMap<String,String>();
map.put(A,"测试数据")；
map.put(B,"测试数据");
```

上边的代码，当A和B在寻址计算完毕之后，假设得到的在数组中的位置都是index0，那么他么就对应了数组中的同一个位置，这种情况被称为哈希冲突。

产生哈希冲突的时候，则会在这个位置挂一个链表，在链表中放入多个元素，让多个键值对，同时放在数组的一个位置离。当做get操作的时候，只需要遍历这个链表从中找到要找的那个值即可。

如果某个位置的链表变得很长，会导致遍历的效率变低，时间复杂度为O(n)，此时就会将这个链表转换为红黑树，遍历红黑树的时间复杂度为O(n)。



### Hashmap扩容

当底层的数组满了之后，会进行扩容，会将原来的容量乘以2。同时，会进行Rehash。这个Rehash的操作指的就是将原来map中的元素重新进行对数组的新长度进行寻址操作。因为数组的长度改变，因此Rehash操作之后，得到的在数组中的新地址可能会与之前的地址不一样。



















