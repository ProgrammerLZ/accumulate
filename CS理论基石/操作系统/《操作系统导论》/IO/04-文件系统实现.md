# 文件系统实现

介绍一个简单的文件系统实现，称为VSFS（Very Simple File System，简单文件系统）。它是典型UNIX文件系统的简化版本，因此可用于介绍一些：

* 基本磁盘结构
* 访问方法
* 各种策略

你可以在当今许多文件系统中看到，文件系统是纯软件，所有这些文件系统都有不同的数据结构，在某些方面优于或逊于同类系统。



==关键问题：如何实现简单的文件系统==

==如何构建一个简单的文件系统？磁盘上需要什么结构？它们需要记录什么？它们如何访问？==



## 思考方式

考虑文件系统时，我们通常建议考虑它们的两个不同方面：

* 文件系统的数据结构

  换言之，文件系统在磁盘上使用哪些类型的结构来组织其数据和元数据？

* 文件系统的访问方法

  如何将进程发出的调用，如open()、read()、write()等，映射到它的结构上？在执行特定系统调用期间读取哪些结构？改写哪些结构？所有这些步骤的执行效率如何？



## 整体组织

开发VSFS文件系统在磁盘上的数据结构的整体组织，第一件事：将磁盘分成快，每块简单的分成4KB。

因此，我们对构建文件系统的磁盘分区的看法很简单：一系列块，每块大小为4KB。在大小为N个4KB块的分区中，这些块的地址为从0到N−1。

一个64块的非常小的磁盘：

![image-20230219092131174](assets/04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image-20230219092131174.png)



后56块用来存放用户数据。

![image-20230219092214812](assets/04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image-20230219092214812.png)





5块用于存放inode。

![image-20230219092252693](assets/04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image-20230219092252693.png)

inode记录诸如**文件包含哪些数据块（在数据区域中）、文件的大小，其所有者和访问权限、访问和修改时间以及其他类似信息**的事情。

一个inode通常是256字节大小。

* 5个块（$5 *4KB*1024 = 20480B$）能够存储80（$20480 / 256 = 80$）个inode。**这个数字表示文件系统中可以拥有的最大文件数量**。

* 每个块能够存储16（$80/5$）个inode。





2块用于记录inode或数据块是空闲还是已分配。

![image-20230219094142070](assets/04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image-20230219094142070.png)

位图是一种简单的结构：每个位用于指示相应的对象/块是空闲（0）还是正在使用（1）。

4KB的位图能够记录32K的对象是否分配，而这里只有80个inode和56个数据块，已经足够用了。





1块保留给超级块。

![image-20230219094557295](assets/04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image-20230219094557295.png)

超级块包含关于该特定文件系统的信息，包括例如文件系统中有多少个inode和数据块（在这个例子中分别为80和56）、inode表的开始位置（块3）等等。它可能还包括一些幻数，来标识文件系统类型（在本例中为VSFS）。

文件系统被挂载后，超级快会存在于内存当中。





## 文件组织inode

文件系统最重要的磁盘结构之一是inode，几乎所有的文件系统都有类似的结构。因为这些节点最初放在一个数组中，在访问特定inode时会用到该数组的索引。

每个inode都由一个数字（称为inumber）隐式引用，我们之前称之为文件的低级名称（low-level name）。给定一个inumber，你应该能够直接计算磁盘上相应节点的位置。

在每个inode中，实际上是所有关于文件的信息，我们将所有关于文件的信息称为**元数据**（metadata），下图所示的是ext2的inode的例子

![image-20230219105432618](assets/04-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/image-20230219105432618.png)

设计inode时，最重要的决定之一是它如何引用数据块的位置。一种简单的方法是**在inode中有一个或多个直接指针（磁盘地址），每个指针指向属于该文件的一个磁盘块**。这种方法有局限：例如，如果你想要一个非常大的文件，该文件占有的磁盘块数量特别多，那么将会有特别多数磁盘地址，inode的空间不够存储这么多指针。



### 多级索引

为了解决大文件的索引，设计者在inode引入了一个称为**间接指针**的特殊指针。它不是指向包含用户数据的块，而是指向包含更多指针的块，每个指针指向用户数据。因此，inode可以有一些固定数量（例如 12个）的直接指针和一个间接指针。如果文件变得足够大，则会分配一个间接块（**来自磁盘的数据块区域**），并将inode的间接指针设置为指向它。

> 假设一个块是4KB，磁盘地址是4字节，那就增加了1024个指针。
>
> 计算：4KB / 4B = 1K = 1024
>
> 文件可以增长到（12 + 1024）×4KB，即4144KB。

当然，在inode设计的空间中，存在许多其他可能性。毕竟，inode只是一个数据结构，**任何存储相关信息并可以有效查询的数据结构就足够了**。由于文件系统软件很容易改变，如果工作负载或技术发生变化，你应该愿意探索不同的设计。





## 目录组织

在VSFS中（像许多文件系统一样），目录的组织很简单。一个目录基本上只包含一个二元组（条目名称，inode号）的列表。

通常，文件系统将目录视为**特殊类型的文件**。因此，目录有一个inode，位于inode表中的某处（inode表中的inode标记为“目录”的类型字段，而不是“常规文件”）。该目录具有由inode指向的数据块（也可能是间接块）。这些数据块存在于简单文件系统的数据块区域中。磁盘结构因此保持不变。





## 空闲空间管理

**文件系统必须记录哪些inode和数据块是空闲的，哪些不是，这样在分配新文件或目录时，就可以为它找到空间**。因此，空闲空间管理（free space management）对于所有文件系统都很重要。在VSFS中，我们用两个简单的**位图**来完成这个任务。

例如，当我们创建一个文件时，我们必须为该文件分配一个inode。文件系统将通过位图搜索一个空闲的inode，并将其分配给该文件。文件系统必须将inode标记为已使用（用1），并最终用正确的信息更新磁盘上的位图。分配数据块时会发生类似的一组活动。





## 访问路径：读取和写入

### 从磁盘读取文件

*先假设你只是想打开一个文件（例如/foo/bar，读取它，然后关闭它）。对于这个简单的例子，假设文件的大小只有4KB（即1块）。*

1. 发出一个`open("/foo/bar", O_RDONLY)`调用，文件系统首先需要找到文件bar的inode，从而获取关于该文件的一些基本信息（权限信息、文件大小等等）。
2. 要找到文件bar的inode，要先读取根目录的inode（/），在大多数UNIX文件系统中，**根的inode号为2**。文件系统会读入inode号为2的inode块。
3. 文件系统在inode块中查找指向数据块的指针，数据块包含根目录的内容。在这些内容中递归寻找foo的条目，foo的条目中读出了foo的inode号，也就能够找到foo的inode。
4. foo的inode种保存了目录foo的信息，通过这些信息能够找到bar的inode号，也就能找到bar的inode。
5. open()的最后一步是将bar的inode读入内存。
6. 文件系统进行最后的权限检查，在每个进程的打开文件表中，为此进程分配一个文件描述符，并将它返回给用户。
7. 程序发出`read()`系统调用，从文件中读取数据。
8. 第一次读取将在文件的第一个块中读取，查阅inode以查找这个块的位置。
9. 更新inod的最后访问时间。
10. 更新此文件描述符在内存中的打开文件表
11. 更新文件偏移量，以便下一次读取会读取第二个文件块，等等。
12. 读取完毕，释放文件描述符。



## 写入磁盘

每次写入文件**在逻辑上**会导致5个I/O：

1. 读取数据位图。
2. 写入数据位图。
3. 读取inode位图。
4. 更新inode位图。
5. 写入真正的数据。

实际上，工作量会更大，录入创建文件：

1. 读取inode位图，以查找空闲inode。
2. 写入inode位图，以标记被分配的inode。
3. 写入inode本身（初始化inode）
4. 写入目录（将文件的高级名称链接到它的inode号）
5. 。。。。。。

不细究了，这块作者写的也很抽象，太浪费时间。

总之，如果直接写入磁盘会有很多次磁盘的I/O，性能很低。





## 缓存和缓冲

==关键问题：如何降低文件系统I/O成本==

==即使是最简单的操作，如打开、读取或写入文件，也会产生大量I/O操作，分散在磁盘上。文件系统可以做些什么，来降低执行如此多I/O的高成本？==

读取和写入文件可能是昂贵的，会导致（慢速）磁盘的许多I/O。这显然是一个巨大的性能问题，为了弥补，大多数文件系统积极使用**系统内存**（DRAM）来缓存重要的块。

简单来说，缓存针对读操作；缓冲针对写操作。

在进行读操作时，第一次读完数据，会将数据放入缓存中，下次读取直接读缓存，缓存容量有限，因此会有一些有用的算法来对缓存中的数据进行淘汰，以尽量保证缓存中存放的是比较热点的数据。

在进行写操作时，上边也看到了，直接写操作性能比较低，因此引入一个内存缓冲区，每次写入数据的时候先写入缓冲区，等缓冲区中积攒了一定数量的数据后，在将数据一次性批量的刷入磁盘当中。但是，缓冲区在机器掉电的时候就会丢数据，因此如果使用缓冲区将会有丢数据的风险，如果应用程序不想用缓冲区，可以直接进行fsync系统调用，直接将数据刷入磁盘，在享受安全的同时，也要接受这种直接写入磁盘带来的效率的下降。









