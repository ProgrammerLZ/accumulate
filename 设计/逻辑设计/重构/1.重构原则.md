## 何谓重构

> 1. 对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。
>
> 2. 使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。

重构不仅仅是整理代码，它提供了一种更高效且受控的代码整理技术。重构的目的是使软件更容易被理解和修改。重构不会改变软件的可观察行为。

使用重构技术开发软件时，把时间分配给两种不同的行为：

* +新功能
* 重构

在开发过程中，可能会经常在这两种行为之间切换。



## 为何重构

重构很有价值（但不是“银弹”），它可以帮助我们始终良好地控制自己的代码。重构是个工具，可以（并且应该）应用于以下几个目的。

* 改进软件设计

* 使软件更容易理解

* 重构帮助找到bug

* 重构提高编程速度

  良好的设计是快速开发的根本

> 作者说：任何能够立刻查阅的东西，他都会故意不去记它，因为他怕把脑袋塞爆。



## 何时重构

不必专门拨出时间进行重构。应该随时随地进行，不应该为重构而重构，之所以重构，是因为想做什么别的什么事，而重构可以帮助你把那些事做好。

**三次法则**

> 事不过三，三则重构。

可以在以下几个时机进行重构。

* 添加功能时重构
* 修补错误时重构
* review代码时重构

**系统当下的行为，只是故事的一部分，如果没有认清这一点，可能就很难长期从事编程工作**。程序变得难以维护，主要可以归结为以下几点原因。

* 难以阅读的程序，难以修改；
* 逻辑重复的程序，难以修改；
* 添加新行为时需要修改已有代码的程序，难以修改；
* 带复杂条件逻辑的程序，难以修改。

**间接层的价值**

* 允许逻辑共享
* 分开解释意图和实现
* 隔离变化
* 封装条件逻辑



## 重构的难题

重构一定有其弊端存在，并非十全十美的。但是，限于目前对重构还没有获得足够的经验，还看不到它的局限性。要在使用重构的过程中，注意重构可能引入的问题。

但是作者仍然提出了重构有几个显而易见的难题：

* 数据库
* 修改接口
* 难以通过重构手法完成的设计改动

**什么时候不应该重构？**

* 当你应该重新编写所有的代码的时候——代码实在太混乱，还不如重新编写。

* 项目已近最后期限

  这个时候重构已经为时已晚，重构所能够体现出来的价值会在项目结束之后才体现出来。未完成的重构会形成“债务”，负债运行的软件也能够运行，但是记得，要及时偿还这些债务。



## 重构与设计

系统的灵活性与系统的可维护性、复杂度成正比。重构让系统在合适的时候加入灵活性，而不必在一开始就非常谨慎地给系统加入各种灵活性。

重构能够让我们不必非得要在一开始就预先思考系统的灵活性，一旦需要灵活性，就可以通过重构来获取。当下只管建造可运行的最简化的系统，至于灵活而复杂的设计，可能大多数时候都不会需要它。



## 重构与性能

重构有的时候的确 可能会让程序运行变慢。但是换个角度考虑，重构也让性能优化变得更简单。除了对性能有严格要求的实时系统，大多数软件都要**先写出可调试的软件，然后调整它以求获得足够的速度**。

有三种编写快速软件的方法，按照严格程度排列依次是：

1. 时间预算法

   在设计之初就有严格的给各个组件分配资源和时间预算，大多数系统都不会有这样的需求。

2. 持续关注法

   要求工程师在任何时间做任何事情时，都要设法保持系统的高性能。很常见，但通常没什么太大作用，因为有一个事实是：大多数程序把大半的时间都放在了一小半代码身上，如果每次做出改动的时候都一视同仁的优化所有代码，那90%的优化都是在浪费时间。

3. **后续优化法**

   先写出构造良好的程序，等进入性能优化阶段在按照某个特定程序来调整程序性能。





















