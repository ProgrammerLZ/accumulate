## 软件架构是如何产生的？

### 不断发展的软件

#### 机器语言 

难写、难读、难改



#### 汇编语言

解决了机器语言的缺点，但是无法在不同CPU下复用。



#### 高级语言

通过编译器，解决了汇编语言的缺点，但之后又诞生了几次基于高级语言的软件危机。



##### 第一次软件危机与结构化程序设计

原因：软件的逻辑变得非常复杂。

危机：软件质量低下、项目无法如期完成、项目严重超支。

解决方案：结构化程序设计。

结构化程序设计的特点：**抛弃goto语句，采取自顶向下、逐步细化、模块化的指导思想**。



##### 第二次软件危机与面向对象的程序设计

原因：结构化程序虽然能够解决软件的逻辑变得非常复杂的问题，但是却对业务变化带来的软件扩展无能为力。

危机：软件生产力远远跟不上硬件和业务的发展。

解决方案：面向对象的程序设计



#### 软件架构

与结构化程序设计和面向对象不同，软件架构出现的背景并不是整个行业都面临类似的问题，软件架构也不是为了解决新的软件危机。

卡内基-梅隆大学的Mary Shaw和David Galan在1994年的一篇文章中写到：

> 随着软件系统规模的增加，计算相关的算法和数据结构不再构成主要的设计问题；当系统有许多部分组成时，整个系统的组织，也就是所说的“软件架构”，导致了一系列新的设计问题。

从这段话中也可以看出来，只有较大规模的软件系统才会面临软件架构相关的问题，例如：

* 系统规模庞大，内部耦合严重，开发效率低下。
* 系统耦合然中，牵一发动全身，后续修改和扩展困难。
* 系统逻辑复杂，容易出问题，出问题后很难排查和修复。



### 软件架构设计的真正目的

#### 回顾历史

20世纪60年代，第一次软件危机引出了“结构化编程”，从而创造了“模块”的概念。

20世纪80年代，第二次软件危机引出了“面向对象编程”，从而穿创造了“对象”的概念

20世纪90年代，“软件架构”开始流程，从而创造了“组件”的概念。

可以看出来“模块”“对象”“组件”本质上都是对达到一定规模的软件进行拆分，差别在于随着软件的复杂度不断增加，查分的粒度越来越粗，拆分的角度越来越高。



#### 从历史中得出结论

整个软件技术发展的历史，其实就是一部与“复杂度”斗争的历史，架构设计也不例外——**架构设计的真正目的是为了解决复杂度带来的问题**。



## 软件架构的分类

软件架构大体分为两大类。

* 单体架构
  * 分层架构
  * 管道架构
  * 微内核架构
* 分布式架构
  * 基于服务的架构
  * 事件驱动架构
  * 基于空间的架构
  * 面向服务的架构
  * 微服务架构



