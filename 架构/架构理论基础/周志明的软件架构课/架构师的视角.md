# 架构师的视角

在这里，作者对架构师特指的是：软件系统中**技术模型的设计者**。这些技术模型的设计者在架构设计的时候：

* 应该思考哪些问题
* 可以选择哪些主流的解决方案和行业标准做法以及这些主流解决方案的优缺点、会给架构设计带来什么影响



## 远程服务调用（RPC）

RPC是构建分布式系统的最基本的前置条件。RPC的主要学习内容包括：

* 它是如何出现的？
* 又是如何发展的？
* 主流的实施手段是什么？

RPC已经有40多年的历史了，不是什么新技术。之所以有如此之高的关注度主要有两点原因：

* 微服务风潮带来的热度
* 开发者对RPC普遍可能理解的不是很到位，有很多的错误认知



### 进程间通讯的方式

进程间通讯解决的是两个进程之间如何交互数据的问题。可以考虑的解决办法有：

* 管道(Pipe)或者具名管道(Named Pipe)

  管道其实类似于两个进程间的桥梁，用于进程间传递少量的字符流或字节流。

* 信号(Signal)

  信号是用来通知目标进程有某种事件发生的。

* 信号量(Semaphore)

  信号量是用于两个进程之间同步协作的手段，相当于操作系统提供的一个特殊变量。我们可以在信号量上，进行 wait() 和 notify() 操作。

* 消息队列(Message Queue)

  程可以向队列中添加消息，而被赋予读权限的进程则可以从队列中消费消息。消息队列就克服了信号承载信息量少、管道只能用于无格式字节流，以及缓冲区大小受限等缺点 ，但实时性相对受限。

* 共享内存(Shared Memory)

  允许多个进程可以访问同一块内存空间，这是效率最高的进程间通讯形式。由于内存是多进程共享的，所以往往会与其它通信机制，如信号量等结合使用，来达到进程间的同步及互斥。

* 本地套接字接口(IPC Socket)

  套接字接口，是更为普适的进程间通信机制，可用于不同机器之间的进程通信。

  基于效率考虑，当仅限于本机进程间通讯的时候，套接字接口是被优化过的，不会经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等操作，只是简单地将应用层数据从一个进程拷贝到另一个进程，这种进程间通讯方式有个专有的名称：Unix Domain Socket，又叫做 **IPC Socket**。

以上都属于IPC——本地过程调用。



### RPC的定义

计算机科学家们最初的想法，就是将 RPC 作为 IPC的一种特例来看待。

因为IPC Socket是操作系统提供的标准接口，所以它完全有可能把远程方法调用的通讯细节，隐藏在操作系统底层，从应用层面上来看，可以做到**远程调用与本地方法调用几乎完全一致**。然而，这种透明的调用形式反而让程序员们**误以为通信是无成本的，从而被滥用，以至于显著降低了分布式系统的性能**。

1987年，安德鲁 · 塔能鲍姆（Andrew Tanenbaum）教授发表了一篇论文“A Critique of the Remote Procedure Call Paradigm”，对这种透明的 RPC 范式提出了一系列质问：

* 两个进程通讯，谁作为服务端，谁作为客户端？

* 怎样进行异常处理？

* 异常该如何让调用者获知？

* 服务端出现多线程竞争之后怎么办？

* 如何提高网络利用的效率，比如连接是否可被多个请求复用以减少开销？

* 是否支持多播？

* 参数、返回值如何表示？

* 应该有怎样的字节序？

* 如何保证网络的可靠性，比如调用期间某个链接忽然断开了怎么办？

* 服务端发送请求后，收不到回复该怎么办？

* ……

论文的中心观点是：**把本地调用与远程调用当作一样的来处理，是犯了方向性的错误，把系统间的调用做成透明的，反而会增加程序员工作的复杂度**。后来，一群大佬对这种透明的RPC罗列出了大大问题：

* 网络是可靠的（The network is reliable）

* 延迟是不存在的（Latency is zero ）

* 带宽是无限的（Bandwidth is infinite）

* 网络是安全的（The network is secure）

* 拓扑结构是一成不变的（Topology doesn't change）

* 总会有一个管理员（There is one administrator）

* 不考虑传输成本（Transport cost is zero）

* 网络是同质化的（The network is homogeneous）

到这时为止，RPC 应该是一种**高层次的，或者说语言层次的特征，而不是像IPC那样，是低层次的，或者说系统层次的特征**，就成为了工业界、学术界的主流观点。

1980 年代初期，施乐 Palo Alto 研究中心，实现了世界上第一个基于 RPC 的商业应用 Courier，这里施乐 PARC 定义的“远程服务调用”的概念，就是符合上面针对 RPC 的结论的。

> 首次提出远程服务调用的定义
>
> Remote procedure call is the synchronous language-level transfer of control between programs in address spaces whose primary communication is a narrow channel.
>
> —— Bruce Jay Nelson，Remote Procedure Call，Xerox PARC，1981
>
> RPC 是一种语言级别的通讯协议，它允许运行于一台计算机上的程序以某种管道作为通讯媒介（即某种传输协议的网络），去调用另外一个地址空间（通常为网络上的另外一台计算机).



### RPC的发展

RPC协议要解决的3个基本问题：

* 数据如何表示
* 数据如何传输
* 方法如何表示

这3个问题的解决有很多的方案，因此出现了很多的RPC协议。

然而在RPC协议的发展过程中，大家明白了一个道理：**简单、普适和高性能，似乎真的难以同时满足**。功能强大的框架往往要在传输中加入额外的负载和控制措施，导致传输性能降低，而如果既想要高性能，又想要强功能，这就必然要依赖大量的技巧去实现，进而也就导致了框架会变得过于复杂，这就决定了**不可能有一个“完美”的框架同时满足简单、普适和高性能这三个要求**。

认识到这一点后，一个 RPC 框架要想取得成功，就要选择一个发展方向，能够非常好地满足某一方面的需求。因此，产生了RPC协议发展的3条线：

* 朝着面向对象发展
* 朝着性能发展
* 朝着简化发展

RPC 的三大问题源自对本地方法调用的类比模拟，如果我们把思维从“方法调用”的约束中挣脱，那参数与结果如何表示、方法如何表示、数据如何传递这些问题，都会海阔天空，拥有焕然一新的视角。



## RESTful服务



